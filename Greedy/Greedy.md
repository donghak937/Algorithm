# Greedy Algorithm (탐욕 알고리즘)

그리디 알고리즘은 **매 선택의 순간마다 당장 눈앞에 보이는 최적의 상황만을 쫓아 최종적인 해답에 도달**하는 방법입니다. 순간마다 하는 선택은 그 순간에는 지역적으로 최적이지만, 그 선택들을 수집하여 최종적인(전역적) 해답을 만들었을 때 그것이 최적이라는 보장은 없습니다. 하지만 많은 경우에 효율적인 근사해를 찾거나, 특정 조건하에서는 최적해를 보장합니다.

### 1. 핵심 조건
그리디 알고리즘이 잘 작동하기 위한 조건입니다.
- **탐욕적 선택 속성 (Greedy Choice Property):** 앞의 선택이 이후의 선택에 영향을 주지 않으면서, 매 순간의 최적 선택이 전체 문제의 최적해로 이어져야 합니다.
- **최적 부분 구조 (Optimal Substructure):** 문제의 최적해가 부분 문제의 최적해로 구성될 수 있어야 합니다.

### 2. 동적 계획법(DP)과의 차이
- **DP:** 모든 가능성을 고려하여 바텀업/탑다운으로 풀어나가며 최적해를 찾습니다. (느리지만 정확)
- **Greedy:** 매 순간 가장 좋아 보이는 것만 선택합니다. (빠르지만 항상 최적해를 보장하지는 않음)

### 3. 예시: 거스름돈 문제 (Coin Change)
가장 대표적인 그리디 예제입니다. 500원, 100원, 50원, 10원짜리 동전이 있을 때, 손님에게 거슬러 줘야 할 돈 `n`원을 **최소 개수의 동전**으로 거슬러 주는 방법입니다.
*단, 동전의 큰 단위가 작은 단위의 배수여야만 그리디가 성립합니다. (예: 500은 100의 배수)*

```cpp
#include <iostream>
#include <vector>
using namespace std;

int min_coin_change(int change) {
    // 큰 단위의 화폐부터 차례대로 확인
    int coins[] = {500, 100, 50, 10};
    int count = 0;
    
    for (int coin : coins) {
        // 해당 화폐로 거슬러 줄 수 있는 동전의 개수 세기
        count += change / coin;
        change %= coin; // 남은 거스름돈 갱신
    }
    
    return count;
}

int main() {
    int n = 1260;
    cout << min_coin_change(n) << endl;
    return 0;
}
```
**실행 결과:**
`1260원`을 거슬러 줄 때: 500원 2개, 100원 2개, 50원 1개, 10원 1개 → 총 6개
